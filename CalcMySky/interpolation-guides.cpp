#define _USE_MATH_DEFINES // for MSVC to define M_PI etc.
#include "interpolation-guides.hpp"
#include <cmath>
#include <vector>
#include <limits>
#include <sstream>
#include <iostream>
#include <QFile>
#include "util.hpp"
#include "../common/util.hpp"

/* Glossary:
 *  * Guide line — a line originating at the guide row and ending at a neighboring
 *     target row. The guide itself (an abstract entity) is supposed to be between the rows.
 *  * Guide origin — the point where the guide line originates. It's represented by
 *     an (integral) index in the guide row.
 *  * Guide target — the point that the guide line ends with in the neighboring row.
 *     It's represented by a fractional index in the row.
 *  * Guide value — the point that the guide line crosses, given a position between
 *     rows. It's represented by a fractional index in the row.
 */

namespace
{

// A single guide is made of two numbers, so we have two items per row.
constexpr int NUMBERS_PER_GUIDE = 2;

// v2v = vector to value
inline float v2v(glm::vec4 const& v)
{
    constexpr int vecIndex = 1; // XXX: maybe we should average over all components, or do something else to get better results.
    return v[vecIndex];
}

float interpolateN(const float N0, const float N1, const float valN0, const float valN1, const float value)
{
    return N0+(N1-N0)*(value-valN0)/(valN1-valN0);
}

enum DirectionInRow
{
    DIR_UP   = +1,
    DIR_DOWN = -1,
};

constexpr int POINT_NOT_FOUND = -1;

/*!
 * Find intersection of the given value with the scaled & shifted values of the given row. The result is the
 * fractional index: such that the given value is between the values of the two closest integer indices.
 * Scaling & shifting makes all the values non-negative, and brings the maxima of each row to one normalized
 * value. This lets us easily trace the maximum. The assumption is that the row has only one maximum.
 */
float findIntersection(float const*const row, const unsigned rowLength,
                       const float value, const unsigned startingPosition, const DirectionInRow dir)
{
    const auto valueAtStartPos = row[startingPosition];
    const bool wantGrowing = value > valueAtStartPos;
    const int endN = dir==DIR_DOWN ? 0 : rowLength-1;
    for(int n = startingPosition; n != endN; n += dir)
    {
        // Scaling & shifting is done here
        const auto valN  = row[n];
        const auto valN1 = row[n+dir];

        if(wantGrowing)
        {
            // If overshot or matched, we've found it
            if(valN1 >= value)
                return interpolateN(n, n+dir, valN, valN1, value);
        }
        else
        {
            // If undershot or matched, we've found it
            if(valN1 <= value)
                return interpolateN(n, n+dir, valN, valN1, value);
        }
    }
    return POINT_NOT_FOUND;
}

}

/*
 * Rows are considered detailed enough to be thought of as smooth functions. The guides generated by this function
 * define the angles at which the interpolation between these rows/columns should be done. This in particular lets
 * the interpolant follow the maximum of each row as if it linearly shifts between each row, instead of simply
 * decaying and letting the maximum in the next row increase separately.
 */
void generateInterpolationGuides2D(glm::vec4 const*const data, const unsigned width, const unsigned height,
                                   const unsigned rowStride, const unsigned guidesRowStride, float* guides)
{
    if(width==0 || height==0)
    {
        std::cerr << "generateInterpolationGuides2D: empty input\n";
        throw MustQuit{};
    }

    const int numRows = height;
    const int numCols = width;

    const auto lessThan = [](glm::vec4 const& v1, glm::vec4 const& v2)
                          { return v2v(v1) < v2v(v2); };

    std::vector<int> maxPositionsPerRow(numRows);
    std::vector<float> minimaPerRow(numRows);
    for(int row = 0; row < numRows; ++row)
    {
        const auto rowData = data+row*rowStride;
        const auto minmax = std::minmax_element(rowData, rowData+numCols, lessThan);
        minimaPerRow[row] = v2v(*minmax.first);
        maxPositionsPerRow[row] = minmax.second - rowData;
    }
    const float globalMin = *std::min_element(minimaPerRow.begin(), minimaPerRow.end());

    std::vector<float> currData(numCols);
    std::vector<float> nextData(numCols);
    constexpr float max = 1; // We operate in normalized values, so that maximum is always 1
    for(int row = 0; row < numRows-1; ++row)
    {
        const auto currRowData = data+row*rowStride;
        const auto currMaxIt = std::max_element(currRowData, currRowData+numCols, lessThan);
        const auto currMax = v2v(*currMaxIt);
        if(currMax == 0)
        {
            guides[row * guidesRowStride + 0] = 0;
            guides[row * guidesRowStride + 1] = 0;
            continue;
        }
        for(int n = 0; n < numCols; ++n)
            currData[n] = (v2v(currRowData[n]) - globalMin) / (currMax - globalMin);
        const unsigned maxPosCurr = currMaxIt - currRowData;
        const float minLeftCurr = *std::min_element(currData.begin(), currData.begin() + maxPosCurr);
        const float minRightCurr = *std::min_element(currData.begin() + maxPosCurr, currData.end());

        const auto nextRowData = data+(row+1)*rowStride;
        const auto nextMaxIt = std::max_element(nextRowData, nextRowData+numCols, lessThan);
        const auto nextMax = v2v(*nextMaxIt);
        if(nextMax == 0)
        {
            guides[row * guidesRowStride + 0] = 0;
            guides[row * guidesRowStride + 1] = 0;
            continue;
        }
        for(int n = 0; n < numCols; ++n)
            nextData[n] = (v2v(nextRowData[n]) - globalMin) / (nextMax - globalMin);
        const unsigned maxPosNext = nextMaxIt - nextRowData;
        const float minLeftNext = *std::min_element(nextData.begin(), nextData.begin() + maxPosNext);
        const float minRightNext = *std::min_element(nextData.begin() + maxPosNext, nextData.end());

        constexpr float smallThreshold = 0.1;
        float smallLevelLeft = minLeftCurr + smallThreshold*(max - minLeftCurr);
        float smallLevelRight = minRightCurr + smallThreshold*(max - minRightCurr);
        if(minLeftNext > smallLevelLeft) smallLevelLeft = minLeftNext;
        if(minRightNext > smallLevelRight) smallLevelRight = minRightNext;

        auto smallLevelPosLeftInCurrRow = findIntersection(currData.data(), currData.size(), smallLevelLeft, maxPosCurr, DIR_DOWN);
        auto smallLevelPosRightInCurrRow = findIntersection(currData.data(), currData.size(), smallLevelRight, maxPosCurr, DIR_UP);
        auto smallLevelPosLeftInNextRow = findIntersection(nextData.data(), nextData.size(), smallLevelLeft, maxPosNext, DIR_DOWN);
        auto smallLevelPosRightInNextRow = findIntersection(nextData.data(), nextData.size(), smallLevelRight, maxPosNext, DIR_UP);
        if(smallLevelPosLeftInCurrRow == POINT_NOT_FOUND) smallLevelPosLeftInCurrRow = 0;
        if(smallLevelPosRightInCurrRow == POINT_NOT_FOUND) smallLevelPosRightInCurrRow = currData.size() - 1;
        if(smallLevelPosLeftInNextRow == POINT_NOT_FOUND) smallLevelPosLeftInNextRow = 0;
        if(smallLevelPosRightInNextRow == POINT_NOT_FOUND) smallLevelPosRightInNextRow = nextData.size() - 1;

        const auto midPosLeft = (smallLevelPosLeftInCurrRow + smallLevelPosLeftInNextRow)/2;
        const auto midPosRight = (smallLevelPosRightInCurrRow + smallLevelPosRightInNextRow)/2;
        const auto tanAngleAtMidPosLeft = smallLevelPosLeftInNextRow - smallLevelPosLeftInCurrRow;
        const auto tanAngleAtMidPosRight = smallLevelPosRightInNextRow - smallLevelPosRightInCurrRow;

        // The coefficients for the equation angle=angleCoefA*pos+angleCoefB
        const float angleCoefA = (tanAngleAtMidPosLeft - tanAngleAtMidPosRight) / (midPosLeft - midPosRight);
        const float angleCoefB = (midPosLeft*tanAngleAtMidPosRight - midPosRight*tanAngleAtMidPosLeft) / (midPosLeft - midPosRight);
        guides[row * guidesRowStride + 0] = angleCoefA;
        guides[row * guidesRowStride + 1] = angleCoefB;
    }
}

void generateInterpolationGuidesForScatteringTexture(const std::string_view filePath, std::vector<glm::vec4> const& pixels,
                                                     std::vector<int> const& sizes)
{
    std::cerr << indentOutput() << "Generating interpolation guides:\n";
    const auto filePathQt = QByteArray::fromRawData(filePath.data(), filePath.size());
    const std::string_view ext = ".f32";
    if(!filePathQt.endsWith(ext.data()))
    {
        std::cerr << "wrong input filename extension\n";
        throw MustQuit{};
    }

    const auto altLayerCount = sizes[3];
    const auto szaLayerCount = sizes[2];
    const auto dVSLayerCount = sizes[1];
    const auto vzaPointCount = sizes[0];
    // Handle dimensions VZA-dotViewSun
    {
        OutputIndentIncrease incr;
        std::cerr << indentOutput() << "Generating interpolation guides for VZA-dotViewSun dimensions... ";

        const auto outputFilePath = filePathQt.left(filePathQt.size() - ext.size()) + "-dims01.guides2dv2";
        QFile out(outputFilePath);
        if(!out.open(QFile::WriteOnly))
        {
            std::cerr << "failed to open interpolation guides file for writing: " << out.errorString().toStdString() << "\n";
            throw MustQuit{};
        }
        {
            // Guides represent points between rows, so there's one less of them than rows.
            uint16_t outputSizes[3] = {uint16_t(sizes[1]-1), uint16_t(sizes[2]), uint16_t(sizes[3])};
            if(out.write(reinterpret_cast<const char*>(outputSizes), sizeof outputSizes) != sizeof outputSizes)
            {
                std::cerr << "failed to write interpolation guides header: " << out.errorString().toStdString() << "\n";
                throw MustQuit{};
            }
        }

        uint16_t rowStride = vzaPointCount, height = dVSLayerCount;
        std::vector<float> guides(NUMBERS_PER_GUIDE*(height-1));
        for(int altIndex = 0; altIndex < altLayerCount; ++altIndex)
        {
            std::ostringstream ss;
            ss << altIndex << " of " << altLayerCount << " layers done ";
            std::cerr << ss.str();

            for(int szaIndex = 0; szaIndex < szaLayerCount; ++szaIndex)
            {
                const int altSliceOffset = altIndex*szaLayerCount*dVSLayerCount*vzaPointCount;
                const int szaSubsliceOffset = szaIndex*vzaPointCount*dVSLayerCount;
                const int aboveHorizonHalfSpaceOffset = vzaPointCount/2 + 1; // +1 skips zenith point, because it may have an extraneous maximum
                const int aboveHorizonHalfSpaceSize = vzaPointCount/2 - 1;   // -1 takes into account the +1 in the offset
                std::fill(guides.begin(), guides.end(), 0.f);
                const int guidesRowStride = NUMBERS_PER_GUIDE;
                generateInterpolationGuides2D(&pixels[altSliceOffset + szaSubsliceOffset + aboveHorizonHalfSpaceOffset],
                                              aboveHorizonHalfSpaceSize, height, rowStride,
                                              guidesRowStride, guides.data());
                out.write(reinterpret_cast<const char*>(guides.data()), guides.size()*sizeof guides[0]);
            }

            // Clear previous status and reset cursor position
            const auto statusWidth=ss.tellp();
            std::cerr << std::string(statusWidth, '\b') << std::string(statusWidth, ' ')
                      << std::string(statusWidth, '\b');
        }
        std::cerr << "done\n";
        std::cerr << indentOutput() << "Saving interpolation guides to \"" << outputFilePath.toStdString() << "\"... ";

        out.close();
        if(out.error())
        {
            std::cerr << "failed to write file: " << out.errorString().toStdString() << "\n";
            throw MustQuit{};
        }
        std::cerr << "done\n";
    }
    // Handle dimensions VZA-SZA
    {
        OutputIndentIncrease incr;
        std::cerr << indentOutput() << "Generating interpolation guides for VZA-SZA dimensions... ";

        const auto outputFilePath = filePathQt.left(filePathQt.size() - ext.size()) + "-dims02.guides2dv2";
        QFile out(outputFilePath);
        if(!out.open(QFile::WriteOnly))
        {
            std::cerr << "failed to open interpolation guides file for writing: " << out.errorString().toStdString() << "\n";
            throw MustQuit{};
        }
        {
            // Guides represent points between rows, so there's one less of them than rows.
            uint16_t outputSizes[3] = {uint16_t(sizes[1]), uint16_t(sizes[2]-1), uint16_t(sizes[3])};
            if(out.write(reinterpret_cast<const char*>(outputSizes), sizeof outputSizes) != sizeof outputSizes)
            {
                std::cerr << "failed to write interpolation guides header: " << out.errorString().toStdString() << "\n";
                throw MustQuit{};
            }
        }

        uint16_t rowStride = vzaPointCount*dVSLayerCount, height = szaLayerCount;
        std::vector<float> guides(NUMBERS_PER_GUIDE*dVSLayerCount*(height-1));
        for(int altIndex = 0; altIndex < altLayerCount; ++altIndex)
        {
            std::ostringstream ss;
            ss << altIndex << " of " << altLayerCount << " layers done ";
            std::cerr << ss.str();

            std::fill(guides.begin(), guides.end(), 0.f);
            for(int dVSIndex = 0; dVSIndex < dVSLayerCount; ++dVSIndex)
            {
                const int altSliceOffset = altIndex*szaLayerCount*dVSLayerCount*vzaPointCount;
                const int dVSSubsliceOffset = vzaPointCount*dVSIndex;
                const int aboveHorizonHalfSpaceOffset = vzaPointCount/2 + 1; // +1 skips zenith point, because it may have an extraneous maximum
                const int aboveHorizonHalfSpaceSize = vzaPointCount/2 - 1;   // -1 takes into account the +1 in the offset
                const int guidesRowStride = dVSLayerCount*NUMBERS_PER_GUIDE;
                generateInterpolationGuides2D(&pixels[altSliceOffset + dVSSubsliceOffset + aboveHorizonHalfSpaceOffset],
                                              aboveHorizonHalfSpaceSize, height, rowStride,
                                              guidesRowStride, guides.data() + NUMBERS_PER_GUIDE*dVSIndex);
            }
            out.write(reinterpret_cast<const char*>(guides.data()), guides.size()*sizeof guides[0]);

            // Clear previous status and reset cursor position
            const auto statusWidth=ss.tellp();
            std::cerr << std::string(statusWidth, '\b') << std::string(statusWidth, ' ')
                      << std::string(statusWidth, '\b');
        }
        std::cerr << "done\n";
        std::cerr << indentOutput() << "Saving interpolation guides to \"" << outputFilePath.toStdString() << "\"... ";

        out.close();
        if(out.error())
        {
            std::cerr << "failed to write file: " << out.errorString().toStdString() << "\n";
            throw MustQuit{};
        }
        std::cerr << "done\n";
    }
}
