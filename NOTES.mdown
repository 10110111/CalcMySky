Each scattering order can be calculated by considering each scattering mechanism separately. E.g. calculate Rayleigh scattering, store in a texture, then Mie scattering, store in another texture, then ice crystal scattering, store in a third texture. When we need to use these textures, we can just calculate incoming radiance separately and add it. So we'll get a nested loop:

 * For each scattering mechanism S we want to generate texture for
  * For each scattering mechanism M we have a previous scattering order texture
    > calculate incoming radiance from texture of M, accumulate scattered radiance in texture of S

This can even be generalized so that, e.g., we could have multiple textures for each scattering mechanism, to get high enough resolution in all relevant variables and still fit data in VRAM. E.g. we could split the texture by altitude.

In Bruneton's model, textures store:
 * (Single Rayleigh scattering + {multiple scatterings (which are mixed Mie & Rayleigh, naturally)}) / Rayleigh_phase_function
 * (Single Mie scattering) / Mie_phase_function
In my model I think the texture will only store multiple scatterings, and then the single Mie and Rayleigh scattering will be rendered at run time, so that both phase functions and Earth's shadow are well-resolved. This run time rendering is inevitable for eclipsed atmosphere anyway, so it's not bad to have it for cylindrically-symmetrically-lit one too.

# TODO:
 * Premultiply number densities by cross-sections so that e.g. extinctions didn't have to be multiplied in the shader.
 * Upgrade uniforms which don't change during the precalculation to true constant expressions.
 * Precompute all the constants like cos(someConstOrUniform) instead of putting this computation into the shader.
